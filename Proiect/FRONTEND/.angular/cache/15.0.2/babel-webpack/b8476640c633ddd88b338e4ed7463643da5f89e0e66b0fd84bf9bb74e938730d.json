{"ast":null,"code":"import { throwError } from 'rxjs';\nimport { catchError, map } from \"rxjs/operators\";\nimport * as i0 from \"@angular/core\";\nexport class ErrorCatchingInterceptor {\n  constructor() {}\n  intercept(request, next) {\n    return next.handle(request).pipe(map(res => {\n      return res;\n    }), catchError(error => {\n      let errorMsg = '';\n      if (error.status == 400) {\n        alert(\"Eroare:\\nData unei vanzari trebuie sa fie inaintea datei aprovizionarii\\nCantitatea unei vanzari trebuie sa fie mai mica sau egala cu cantitatea disponibila de medicament\\nCantitatea unei aprovizionari trebuie sa fie mai mare sau egala cu suma tuturor vanzarilor\");\n      } else if (error.status == 409) {\n        alert(\"Conflict:\\nNu putem sterge o aprovizionare daca exista vanzari\\nCNP-ul unui client trebuie sa fie unic\");\n      } else if (error.status == 500) {\n        console.log(\"Eroare server, vezi spring\");\n      } else {\n        console.log(errorMsg);\n      }\n      return throwError(errorMsg);\n    }));\n  }\n  static #_ = this.ɵfac = function ErrorCatchingInterceptor_Factory(t) {\n    return new (t || ErrorCatchingInterceptor)();\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ErrorCatchingInterceptor,\n    factory: ErrorCatchingInterceptor.ɵfac\n  });\n}","map":{"version":3,"mappings":"AAEA,SAAoBA,UAAU,QAAO,MAAM;AAC3C,SAAQC,UAAU,EAAEC,GAAG,QAAO,gBAAgB;;AAG9C,OAAM,MAAOC,wBAAwB;EAErCC,eACA;EAEAC,SAAS,CAACC,OAA6B,EAAEC,IAAiB;IACrD,OAAOA,IAAI,CAACC,MAAM,CAACF,OAAO,CAAC,CACpBG,IAAI,CACCP,GAAG,CAACQ,GAAG,IAAG;MACP,OAAOA,GAAG;IACb,CAAC,CAAC,EACFT,UAAU,CAAEU,KAAwB,IAAI;MACrC,IAAIC,QAAQ,GAAG,EAAE;MACjB,IAAGD,KAAK,CAACE,MAAM,IAAI,GAAG,EAAE;QACpBC,KAAK,CAAC,wQAAwQ,CAAC;OAClR,MAAO,IAAIH,KAAK,CAACE,MAAM,IAAI,GAAG,EAAE;QAC7BC,KAAK,CAAC,wGAAwG,CAAC;OAClH,MAAO,IAAIH,KAAK,CAACE,MAAM,IAAI,GAAG,EAAE;QAC7BE,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;OAC5C,MAAM;QACHD,OAAO,CAACC,GAAG,CAACJ,QAAQ,CAAC;;MAEzB,OAAOZ,UAAU,CAACY,QAAQ,CAAC;IAC9B,CAAC,CAAC,CACP;EACZ;EAAC;qBAzBYT,wBAAwB;EAAA;EAAA;WAAxBA,wBAAwB;IAAAc,SAAxBd,wBAAwB;EAAA","names":["throwError","catchError","map","ErrorCatchingInterceptor","constructor","intercept","request","next","handle","pipe","res","error","errorMsg","status","alert","console","log","factory"],"sourceRoot":"","sources":["/home/luiza/Documents/proiectDBnou/Angular/src/app/interceptor/error-catching-interceptor.ts"],"sourcesContent":["import {Injectable} from '@angular/core';\nimport {HttpErrorResponse, HttpEvent, HttpHandler, HttpInterceptor, HttpRequest} from '@angular/common/http';\nimport {Observable, throwError} from 'rxjs';\nimport {catchError, map} from \"rxjs/operators\";\n\n@Injectable()\nexport class ErrorCatchingInterceptor implements HttpInterceptor {\n\nconstructor() {\n}\n\nintercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {\n     return next.handle(request)\n           .pipe(\n                 map(res => {\n                    return res\n                 }),\n                 catchError((error: HttpErrorResponse) => {\n                    let errorMsg = '';\n                    if(error.status == 400) {\n                        alert(\"Eroare:\\nData unei vanzari trebuie sa fie inaintea datei aprovizionarii\\nCantitatea unei vanzari trebuie sa fie mai mica sau egala cu cantitatea disponibila de medicament\\nCantitatea unei aprovizionari trebuie sa fie mai mare sau egala cu suma tuturor vanzarilor\")\n                    }  else if (error.status == 409) {\n                        alert(\"Conflict:\\nNu putem sterge o aprovizionare daca exista vanzari\\nCNP-ul unui client trebuie sa fie unic\");\n                    }  else if (error.status == 500) {\n                        console.log(\"Eroare server, vezi spring\")\n                    } else {\n                        console.log(errorMsg);\n                    }\n                    return throwError(errorMsg);\n                 })\n           )\n}\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}